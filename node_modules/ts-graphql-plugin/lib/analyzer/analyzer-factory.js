"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const analyzer_1 = require("./analyzer");
const schema_manager_factory_1 = require("../schema-manager/schema-manager-factory");
class ScriptHost {
    constructor(_currentDirectory, _compilerOptions) {
        this._currentDirectory = _currentDirectory;
        this._compilerOptions = _compilerOptions;
        this._fileMap = new Map();
        this._fileVersionMap = new Map();
    }
    readFile(fileName) {
        const hit = this._fileMap.get(fileName);
        if (hit)
            return hit;
        return this.updateFile(fileName);
    }
    updateFile(fileName) {
        const content = typescript_1.default.sys.readFile(fileName, 'uts8');
        if (content)
            this._fileMap.set(fileName, content);
        const currentVersion = this._fileVersionMap.get(fileName) || 0;
        this._fileVersionMap.set(fileName, currentVersion + 1);
        return content;
    }
    getCurrentDirectory() {
        return this._currentDirectory;
    }
    getScriptSnapshot(fileName) {
        const file = this._fileMap.get(fileName);
        if (!file)
            return;
        return typescript_1.default.ScriptSnapshot.fromString(file);
    }
    getScriptVersion(fileName) {
        const version = this._fileVersionMap.get(fileName);
        if (!version)
            return '0';
        return version + '';
    }
    getScriptFileNames() {
        return [...this._fileMap.keys()];
    }
    getCompilationSettings() {
        return this._compilerOptions;
    }
    getDefaultLibFileName(opt) {
        return typescript_1.default.getDefaultLibFileName(opt);
    }
}
exports.ScriptHost = ScriptHost;
class SystemSchemaManagerHost {
    constructor(_pluginConfig, _prjRootPath, _debug) {
        this._pluginConfig = _pluginConfig;
        this._prjRootPath = _prjRootPath;
        this._debug = _debug;
    }
    log(msg) {
        return this._debug(msg);
    }
    watchFile(path, cb, interval) {
        return typescript_1.default.sys.watchFile(path, cb, interval);
    }
    readFile(path, encoding) {
        return typescript_1.default.sys.readFile(path, encoding);
    }
    fileExists(path) {
        return typescript_1.default.sys.fileExists(path);
    }
    getConfig() {
        return this._pluginConfig;
    }
    getProjectRootPath() {
        return this._prjRootPath;
    }
}
class AnalyzerFactory {
    createAnalyzerAndScriptHostFromProjectPath(projectPath, debug = () => { }, currentDirectory = process.cwd()) {
        const { pluginConfig, tsconfig, prjRootPath } = this._readTsconfig(projectPath);
        const scriptHost = new ScriptHost(currentDirectory, tsconfig.options);
        tsconfig.fileNames.forEach(fileName => scriptHost.readFile(fileName));
        const schemaManagerHost = new SystemSchemaManagerHost(pluginConfig, prjRootPath, debug);
        const schemaManager = new schema_manager_factory_1.SchemaManagerFactory(schemaManagerHost).create();
        const analyzer = new analyzer_1.Analyzer(pluginConfig, prjRootPath, scriptHost, schemaManager, debug);
        return { analyzer, scriptHost };
    }
    createAnalyzerFromProjectPath(projectPath, debug = () => { }, currentDirectory = process.cwd()) {
        return this.createAnalyzerAndScriptHostFromProjectPath(projectPath, debug, currentDirectory).analyzer;
    }
    _readTsconfig(project) {
        const currentDirectory = typescript_1.default.sys.getCurrentDirectory();
        const ppath = path_1.default.isAbsolute(project) ? path_1.default.resolve(currentDirectory, project) : project;
        let configPath = undefined;
        if (typescript_1.default.sys.fileExists(ppath)) {
            configPath = ppath;
        }
        else if (typescript_1.default.sys.directoryExists(ppath) && typescript_1.default.sys.fileExists(path_1.default.join(ppath, 'tsconfig.json'))) {
            configPath = path_1.default.join(ppath, 'tsconfig.json');
        }
        if (!configPath) {
            throw new Error(`tsconfig file not found: ${project}`);
        }
        const tsconfig = typescript_1.default.getParsedCommandLineOfConfigFile(configPath, {}, typescript_1.default.sys);
        if (!tsconfig) {
            throw new Error(`Failed to parse: ${configPath}`);
        }
        const prjRootPath = path_1.default.dirname(configPath);
        const plugins = tsconfig.options.plugins;
        if (!plugins || !Array.isArray(plugins)) {
            throw new Error(`tsconfig.json should have ts-graphql-plugin setting. Add the following:
  "compilerOptions": {
    "plugins": [
      {
        "name": "ts-graphql-plugin",
        "schema": "shema.graphql",   /* Path to your GraphQL schema */
        "tag": "gql"                 /* Template tag function name */
      }
    ]
  }`);
        }
        const found = plugins.find((p) => p.name === 'ts-graphql-plugin');
        if (!found) {
            throw new Error(`tsconfig.json should have ts-graphql-plugin setting. Add the following:
  "compilerOptions": {
    "plugins": [
      {
        "name": "ts-graphql-plugin",
        "schema": "shema.graphql",   /* Path to your GraphQL schema */
        "tag": "gql"                 /* Template tag function name */
      }
    ]
  }`);
        }
        const pluginConfig = found;
        return {
            tsconfig,
            pluginConfig,
            prjRootPath,
        };
    }
}
exports.AnalyzerFactory = AnalyzerFactory;
//# sourceMappingURL=analyzer-factory.js.map