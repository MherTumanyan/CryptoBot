"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const graphql_1 = require("graphql");
const language_1 = require("graphql/language");
class Stack {
    constructor(_initializer) {
        this._initializer = _initializer;
        this._array = [];
    }
    get current() {
        if (!this._array.length) {
            throw new Error('Invalid stack state.');
        }
        return this._array[this._array.length - 1];
    }
    stack(value) {
        if (value === undefined && this._initializer) {
            this._array.push(this._initializer());
            return;
        }
        else if (value !== undefined) {
            this._array.push(value);
        }
        else {
            throw new Error();
        }
    }
    consume() {
        const current = this.current;
        this._array.pop();
        return current;
    }
    get isEmpty() {
        return this._array.length === 0;
    }
}
class TypeGenError extends Error {
    constructor(message, node) {
        super(message);
        this.message = message;
        this.node = node;
    }
}
exports.TypeGenError = TypeGenError;
class TypeGenVisitor {
    constructor({ schema }) {
        this._schema = schema;
    }
    visit(documentNode, { outputFileName }) {
        const statements = [];
        const parentTypeStack = new Stack();
        const resultFieldElementStack = new Stack(() => ({
            members: [],
            typeFragments: [],
        }));
        const variableElementStack = new Stack(() => ({
            members: [],
            typeFragments: [],
        }));
        const fieldMetadataMap = new Map();
        const fragmentMap = new Map();
        documentNode.definitions.forEach(def => {
            if (def.kind === 'FragmentDefinition') {
                fragmentMap.set(def.name.value, def);
            }
        });
        language_1.visit(documentNode, {
            OperationDefinition: {
                enter: node => {
                    if (node.operation === 'query') {
                        const queryType = this._schema.getQueryType();
                        if (!queryType) {
                            throw new TypeGenError(`Schema does not have Query type.`, node);
                        }
                        parentTypeStack.stack(queryType);
                        resultFieldElementStack.stack();
                    }
                    else if (node.operation === 'mutation') {
                        const mutationType = this._schema.getMutationType();
                        if (!mutationType) {
                            throw new TypeGenError(`Schema does not have Mutation type.`, node);
                        }
                        parentTypeStack.stack(mutationType);
                        resultFieldElementStack.stack();
                    }
                    else if (node.operation === 'subscription') {
                        const subscriptionType = this._schema.getSubscriptionType();
                        if (!subscriptionType) {
                            throw new TypeGenError(`Schema does not have Subscription type.`, node);
                        }
                        parentTypeStack.stack(subscriptionType);
                        resultFieldElementStack.stack();
                    }
                    variableElementStack.stack();
                },
                leave: node => {
                    statements.push(this._createTsTypeDeclaration(node.name ? node.name.value : 'QueryResult', resultFieldElementStack.consume()));
                    statements.push(this._createTsTypeDeclaration(node.name ? node.name.value + 'Variables' : 'QueryVariables', variableElementStack.consume()));
                    parentTypeStack.consume();
                },
            },
            VariableDefinition: {
                leave: node => {
                    const { typeNode: { name: { value: inputTypeName }, }, list, strict, } = this._getFieldMetadataFromTypeNode(node.type);
                    const variableType = this._schema.getType(inputTypeName);
                    if (!variableType) {
                        throw new TypeGenError(`Schema does not have InputType "${inputTypeName}".`, node);
                    }
                    const visitVariableType = (name, variableType, list, strict, optional) => {
                        let typeNode;
                        if (variableType instanceof graphql_1.GraphQLScalarType) {
                            typeNode = this._createTsTypeNodeFromScalar(variableType);
                        }
                        else if (variableType instanceof graphql_1.GraphQLEnumType) {
                            typeNode = this._createTsTypeNodeFromEnum(variableType);
                        }
                        else if (variableType instanceof graphql_1.GraphQLInputObjectType) {
                            variableElementStack.stack();
                            Object.entries(variableType.getFields()).forEach(([fieldName, v]) => {
                                const { fieldType, list, strict } = this._getFieldMetadataFromFieldTypeInstance(v);
                                visitVariableType(fieldName, fieldType, list, strict, false);
                            });
                            typeNode = this._createTsFieldTypeNode(variableElementStack.consume());
                        }
                        if (!typeNode) {
                            throw new Error('Unknown variable input type. ' + variableType.toJSON());
                        }
                        typeNode = this._wrapTsTypeNodeWithModifiers(typeNode, list, strict);
                        variableElementStack.current.members.push(typescript_1.default.createPropertySignature(undefined, name, optional ? typescript_1.default.createToken(typescript_1.default.SyntaxKind.QuestionToken) : undefined, typeNode, undefined));
                    };
                    visitVariableType(node.variable.name.value, variableType, list, strict, !!node.defaultValue);
                },
            },
            FragmentDefinition: {
                enter: node => {
                    const conditionNamedType = this._schema.getType(node.typeCondition.name.value);
                    parentTypeStack.stack(conditionNamedType);
                    resultFieldElementStack.stack();
                },
                leave: node => {
                    statements.push(this._createTsTypeDeclaration(node.name.value, resultFieldElementStack.consume()));
                    parentTypeStack.consume();
                },
            },
            FragmentSpread: {
                leave: node => {
                    const fragmentDefNode = fragmentMap.get(node.name.value);
                    const isUnionCondition = this._isConcreteTypeOfParentUnionType(fragmentDefNode.typeCondition, parentTypeStack.current);
                    resultFieldElementStack.current.typeFragments.push({
                        isUnionCondition,
                        typeNode: typescript_1.default.createTypeReferenceNode(node.name.value, undefined),
                    });
                },
            },
            InlineFragment: {
                enter: node => {
                    if (!node.typeCondition)
                        return;
                    const conditionNamedType = this._schema.getType(node.typeCondition.name.value);
                    parentTypeStack.stack(conditionNamedType);
                    resultFieldElementStack.stack();
                },
                leave: node => {
                    if (!node.typeCondition)
                        return;
                    parentTypeStack.consume();
                    const typeNode = this._createTsFieldTypeNode(resultFieldElementStack.consume());
                    const isUnionCondition = this._isConcreteTypeOfParentUnionType(node.typeCondition, parentTypeStack.current);
                    resultFieldElementStack.current.typeFragments.push({
                        isUnionCondition,
                        typeNode,
                    });
                },
            },
            Field: {
                enter: node => {
                    if (node.name.value === '__typename')
                        return;
                    if (parentTypeStack.current instanceof graphql_1.GraphQLUnionType) {
                        throw new TypeGenError("Selections can't be made directly on unions.", node);
                    }
                    const field = parentTypeStack.current.getFields()[node.name.value];
                    if (!field) {
                        throw new TypeGenError(`Type "${parentTypeStack.current.name}" does not have field "${node.name.value}".`, node);
                    }
                    const fieldMetadata = this._getFieldMetadataFromFieldTypeInstance(field);
                    if (fieldMetadata.fieldType instanceof graphql_1.GraphQLObjectType ||
                        fieldMetadata.fieldType instanceof graphql_1.GraphQLInterfaceType ||
                        fieldMetadata.fieldType instanceof graphql_1.GraphQLUnionType) {
                        parentTypeStack.stack(fieldMetadata.fieldType);
                        resultFieldElementStack.stack();
                    }
                    fieldMetadataMap.set(node, fieldMetadata);
                },
                leave: node => {
                    if (node.name.value === '__typename') {
                        resultFieldElementStack.current.members.push(this._createTsDoubleUnderscoreTypenameFieldType(parentTypeStack.current));
                        return;
                    }
                    const { fieldType, strict, list } = fieldMetadataMap.get(node);
                    let typeNode;
                    if (fieldType instanceof graphql_1.GraphQLScalarType) {
                        typeNode = this._createTsTypeNodeFromScalar(fieldType);
                    }
                    else if (fieldType instanceof graphql_1.GraphQLEnumType) {
                        typeNode = this._createTsTypeNodeFromEnum(fieldType);
                    }
                    else if (fieldType instanceof graphql_1.GraphQLObjectType ||
                        fieldType instanceof graphql_1.GraphQLInterfaceType ||
                        fieldType instanceof graphql_1.GraphQLUnionType) {
                        typeNode = this._createTsFieldTypeNode(resultFieldElementStack.consume());
                        parentTypeStack.consume();
                    }
                    if (!typeNode) {
                        throw new Error('Unknown field output type. ' + fieldType.toJSON());
                    }
                    typeNode = this._wrapTsTypeNodeWithModifiers(typeNode, list, strict);
                    resultFieldElementStack.current.members.push(typescript_1.default.createPropertySignature(undefined, node.alias ? node.alias.value : node.name.value, undefined, typeNode, undefined));
                    fieldMetadataMap.delete(node);
                },
            },
        });
        const sourceFile = typescript_1.default.createSourceFile(outputFileName, '', typescript_1.default.ScriptTarget.Latest, false, typescript_1.default.ScriptKind.TS);
        const resultFile = typescript_1.default.updateSourceFileNode(sourceFile, statements);
        if (resultFile.statements.length) {
            typescript_1.default.addSyntheticLeadingComment(resultFile.statements[0], typescript_1.default.SyntaxKind.MultiLineCommentTrivia, ' eslint-disable ', true);
            typescript_1.default.addSyntheticLeadingComment(resultFile.statements[0], typescript_1.default.SyntaxKind.MultiLineCommentTrivia, ' This is an autogenerated file. Do not edit this file directly! ', true);
        }
        return resultFile;
    }
    _getFieldMetadataFromFieldTypeInstance(field) {
        let fieldType = field.type;
        let listTypeKind;
        let isStrict;
        if (fieldType instanceof graphql_1.GraphQLNonNull) {
            fieldType = fieldType.ofType;
            if (fieldType instanceof graphql_1.GraphQLList) {
                fieldType = fieldType.ofType;
                listTypeKind = 'strictList';
                if (fieldType instanceof graphql_1.GraphQLNonNull) {
                    fieldType = fieldType.ofType;
                    isStrict = true;
                }
                else {
                    isStrict = false;
                }
            }
            else {
                isStrict = true;
                listTypeKind = 'none';
            }
        }
        else if (fieldType instanceof graphql_1.GraphQLList) {
            fieldType = fieldType.ofType;
            listTypeKind = 'nullableList';
            if (fieldType instanceof graphql_1.GraphQLNonNull) {
                fieldType = fieldType.ofType;
                isStrict = true;
            }
            else {
                isStrict = false;
            }
        }
        else {
            listTypeKind = 'none';
            isStrict = false;
        }
        return {
            fieldType: fieldType,
            list: listTypeKind,
            strict: isStrict,
        };
    }
    _getFieldMetadataFromTypeNode(node) {
        let typeNode = node;
        let listTypeKind;
        let isStrict;
        if (typeNode.kind === 'NonNullType') {
            typeNode = typeNode.type;
            if (typeNode.kind === 'ListType') {
                typeNode = typeNode.type;
                listTypeKind = 'strictList';
                if (typeNode.kind === 'NonNullType') {
                    typeNode = typeNode.type;
                    isStrict = true;
                }
                else {
                    isStrict = false;
                }
            }
            else {
                isStrict = true;
                listTypeKind = 'none';
            }
        }
        else if (typeNode.kind === 'ListType') {
            typeNode = typeNode.type;
            listTypeKind = 'nullableList';
            if (typeNode.kind === 'NonNullType') {
                typeNode = typeNode.type;
                isStrict = true;
            }
            else {
                isStrict = false;
            }
        }
        else {
            listTypeKind = 'none';
            isStrict = false;
        }
        return { typeNode: typeNode, list: listTypeKind, strict: isStrict };
    }
    _isConcreteTypeOfParentUnionType(typeCondition, parentType) {
        if (parentType instanceof graphql_1.GraphQLUnionType) {
            const unionElementTypes = parentType.getTypes();
            return unionElementTypes.some(ut => ut.name === typeCondition.name.value);
        }
        else {
            return false;
        }
    }
    _wrapTsTypeNodeWithModifiers(typeNode, list, strict) {
        if (!strict) {
            typeNode = typescript_1.default.createUnionTypeNode([typeNode, typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.NullKeyword)]);
        }
        if (list === 'strictList' || list === 'nullableList') {
            typeNode = typescript_1.default.createArrayTypeNode(typeNode);
            if (list === 'nullableList') {
                typeNode = typescript_1.default.createUnionTypeNode([typeNode, typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.NullKeyword)]);
            }
        }
        return typeNode;
    }
    _createTsTypeNodeFromEnum(fieldType) {
        return typescript_1.default.createUnionTypeNode(fieldType.getValues().map(v => typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(v.value))));
    }
    _createTsDoubleUnderscoreTypenameFieldType(parentType) {
        if (parentType instanceof graphql_1.GraphQLObjectType) {
            return typescript_1.default.createPropertySignature(undefined, '__typename', undefined, typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(parentType.name)), undefined);
        }
        else if (parentType instanceof graphql_1.GraphQLUnionType) {
            return typescript_1.default.createPropertySignature(undefined, '__typename', undefined, typescript_1.default.createUnionTypeNode(parentType.getTypes().map(t => typescript_1.default.createLiteralTypeNode(typescript_1.default.createStringLiteral(t.name)))), undefined);
        }
        else {
            return typescript_1.default.createPropertySignature(undefined, '__typename', undefined, typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword), undefined);
        }
    }
    _createTsTypeNodeFromScalar(fieldType) {
        switch (fieldType.name) {
            case 'Boolean':
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.BooleanKeyword);
            case 'String':
            case 'ID':
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.StringKeyword);
            case 'Int':
            case 'Float':
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.NumberKeyword);
            default:
                return typescript_1.default.createKeywordTypeNode(typescript_1.default.SyntaxKind.AnyKeyword);
        }
    }
    _createTsTypeDeclaration(name, fieldTypeElement) {
        return typescript_1.default.createTypeAliasDeclaration(undefined, typescript_1.default.createModifiersFromModifierFlags(typescript_1.default.ModifierFlags.Export), name, undefined, this._createTsFieldTypeNode(fieldTypeElement));
    }
    _createTsFieldTypeNode({ members, typeFragments }) {
        if (!members.length && !typeFragments.length) {
            return typescript_1.default.createTypeLiteralNode(undefined);
        }
        const toUnionElements = [];
        const toIntersectionElements = [];
        typeFragments.forEach(({ isUnionCondition, typeNode }) => {
            if (isUnionCondition) {
                toUnionElements.push(typeNode);
            }
            else {
                toIntersectionElements.push(typeNode);
            }
        });
        if (toUnionElements.length) {
            toIntersectionElements.push(typescript_1.default.createUnionTypeNode(toUnionElements));
        }
        if (members.length) {
            toIntersectionElements.unshift(typescript_1.default.createTypeLiteralNode(members));
        }
        return typescript_1.default.createIntersectionTypeNode(toIntersectionElements);
    }
}
exports.TypeGenVisitor = TypeGenVisitor;
//# sourceMappingURL=type-gen-visitor.js.map