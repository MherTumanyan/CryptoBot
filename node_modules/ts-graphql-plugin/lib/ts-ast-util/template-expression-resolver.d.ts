import * as ts from 'typescript';
export declare type ComputePosition = (innerPosition: number) => {
    fileName: string;
    pos: number;
    isInOtherExpression?: boolean;
};
/**
 *
 * Serves the following information.
 *
 * - interpolated string
 * - positon converting functions between TS source and GraphQL document
 *
 **/
export interface ResolvedTemplateInfo {
    combinedText: string;
    getInnerPosition: ComputePosition;
    getSourcePosition: ComputePosition;
    convertInnerPosition2InnerLocation: (pos: number) => {
        line: number;
        character: number;
    };
    convertInnerLocation2InnerPosition: (location: {
        line: number;
        character: number;
    }) => number;
}
export interface ResolveErrorInfo {
    fileName: string;
    start: number;
    end: number;
}
export interface ResolveResult {
    resolvedInfo?: ResolvedTemplateInfo;
    resolveErrors: ResolveErrorInfo[];
}
export declare function createResultForNoSubstitution(node: ts.NoSubstitutionTemplateLiteral, fileName: string): ResolvedTemplateInfo;
declare class ResultCache<S> {
    private _maxSize;
    private _cacheMap;
    constructor(_maxSize?: number);
    set(key: ts.Node, value: S): void;
    get(key: ts.Node): S | undefined;
    has(key: ts.Node): boolean;
    touch(key: ts.Node): void;
    del(key: ts.Node): void;
}
export declare class TemplateExpressionResolver {
    private readonly _langService;
    private readonly _getFileVersion;
    /** @internal **/
    readonly _resultCache: ResultCache<{
        result: ResolvedTemplateInfo;
        dependencyVersions: {
            fileName: string;
            version: string;
        }[];
    }>;
    /** @internal **/
    readonly _stringValueCache: ResultCache<{
        result: string | undefined;
        dependencyVersions: {
            fileName: string;
            version: string;
        }[];
    }>;
    logger: (msg: string) => void;
    constructor(_langService: ts.LanguageService, _getFileVersion: (fileName: string) => string);
    resolve(fileName: string, node: ts.TaggedTemplateExpression | ts.NoSubstitutionTemplateLiteral | ts.TemplateExpression): ResolveResult;
    update(target: ResolvedTemplateInfo, innerPositionRangeToChange: {
        start: number;
        end: number;
    }, text?: string): ResolvedTemplateInfo;
    private _getValueAsString;
}
export {};
