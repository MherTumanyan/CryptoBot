import gql from 'graphql-tag';
import mongoose, { Schema, model } from 'mongoose';
// tslint:disable-next-line: no-implicit-dependencies
import { MongoMemoryServer } from 'mongodb-memory-server';

import { clearDatabase } from '../../../helpers/db.handler';
import { ParseToMongoose, createMongooseSchema } from '../src';

jasmine.DEFAULT_TIMEOUT_INTERVAL = 600000;

let mongoServer;

const schema = gql`
	enum EType {
		field1
		field2
	}

	union UnionName = simple | simple1

	scalar Date

	type simple {
		prop1: String! @default(value: "prop1") @unique @minlength(value: 4) @maxlength(value: 10)
		prop2: String @ObjectId
	}

	input simple1 {
		prop1: [String]
		prop2: [Int] @ObjectId
		prop3: [Boolean]!
	}

	type NonPrimitive @collection(value: "nonprimitives") {
		prop1: simple
		prop2: [simple]
		prop3: String @default(value: "prop3Value")
	}

	type NonEntityTypes {
		prop1: EType
		prop2: UnionName
		prop3: Date
	}

	type Descendant @extends(value: "simple") {
		des1: String @hash
	}

	type A {
		a: String @uuid
	}

	type B {
		a: String @uuid
	}

	type C {
		a: String @uuid
		id: String
	}

	type D {
		a: ID @setonce
		b: String
	}
`;

const schema1 = gql`
	type A {
		a: String
		bb: B
	}

	type B {
		aa: A
		b: String
	}
`;

describe('ParseToMongoose', () => {
	let testEntity: ParseToMongoose;

	beforeAll(async () => {
		mongoServer = new MongoMemoryServer();
		const mongoUri = await mongoServer.getConnectionString();
		await mongoose.connect(mongoUri, (err) => {
			if (err) {
				console.error(err);
			}
		});
	});

	beforeEach(() => {
		testEntity = new ParseToMongoose(schema);
	});

	afterEach(async () => clearDatabase());

	afterAll(async () => {
		await mongoose.disconnect();
		await mongoServer.stop();
	});

	describe('getEntityByName', () => {
		it('returns parsed simple entity, check for simple directives', () => {
			const simpleEntity = testEntity.getEntityByName('simple');
			expect(simpleEntity.schema).toMatchObject({
				prop1: {
					type: 'String',
					default: 'prop1',
					required: true,
					unique: true,
					maxLength: 10,
					minLength: 4,
					trim: true
				}
			});
		});

		it('throws error if entity name not exist in schema definition', () => {
			try {
				testEntity.getEntityByName('IamNotIn');
			} catch (err) {
				expect(err).toMatchObject(new Error('IamNotIn not found'));
			}
		});
	});

	describe('getEntityCollectionValue, returns parsed entity', () => {
		it('check for ObjectId directive', () => {
			const fieldWithObjectId = testEntity.getEntityByName('simple').schema.prop2;
			expect(fieldWithObjectId.type).toBe('ObjectId');
		});

		it('check for array types', () => {
			const entitySchema = testEntity.getEntityByName('simple1').schema;
			expect(entitySchema.prop1.type).toEqual(['String']);
			expect(entitySchema.prop2.type).toEqual(['ObjectId']);
			// ** trim default value is 'true'
			expect(entitySchema.prop3).toMatchObject({ type: ['Boolean'], required: true, trim: true });
		});

		it('check for non primitive types', () => {
			const entitySchema = testEntity.getEntityByName('NonPrimitive').schema;
			expect(entitySchema.prop1).toBeInstanceOf(Object);

			expect(entitySchema.prop1).toMatchObject({
				prop1: {
					type: 'String',
					default: 'prop1',
					required: true,
					unique: true,
					maxLength: 10,
					minLength: 4,
					trim: true
				},
				prop2: { type: 'ObjectId', trim: true }
			});
			// ** check for array of non primitive
			expect(entitySchema.prop2.type).toBeInstanceOf(Array);
		});

		it('check for non entity types', () => {
			const entitySchema = testEntity.getEntityByName('NonEntityTypes').schema;

			// ** enum type checking
			expect(entitySchema.prop1).toMatchObject({ type: 'String', enum: ['field1', 'field2'] });

			// ** union type checking
			expect(entitySchema.prop2.type).toBe('Mixed');

			// ** scalar type
			expect(entitySchema.prop3.type).toBe('Date');
		});

		it('check for extends and hash directives', () => {
			const entitySchema = testEntity.getEntityByName('Descendant').schema;
			// ** checks existance of properties
			expect(entitySchema).toHaveProperty('des1');
			expect(entitySchema).toHaveProperty('prop1');
			expect(entitySchema).toHaveProperty('prop2');

			// ** checks if extended field parsed correctly
			expect(entitySchema.prop2).toMatchObject({ type: 'ObjectId', trim: true });

			// ** hash checking(it hashes the given value in set function)
			expect(entitySchema.des1).toHaveProperty('set');
		});
	});

	describe('getEntityCollectionValue', () => {
		it('returns the value of collection', () => {
			const colletionName = testEntity.getEntityCollectionValue('NonPrimitive');
			expect(colletionName).toBe('nonprimitives');
		});

		it('returns undefind if value not given', () => {
			const colletionName = testEntity.getEntityCollectionValue('simple');
			expect(colletionName).toBeUndefined();
		});
	});

	describe('getEntitySchema', () => {
		it('returns the schema entity which have collection directive', () => {
			const entitySchema = testEntity.getEntitySchema('NonPrimitive');
			expect(entitySchema).toBeInstanceOf(Schema);
			expect(entitySchema).toBeTruthy();
		});

		it('returns undefind if collection not exist on entity', () => {
			const entitySchema = testEntity.getEntityCollectionValue('simple');
			expect(entitySchema).toBeUndefined();
		});
	});

	describe('cycle', () => {
		it('throws error if types called under each other', () => {
			try {
				const p = new ParseToMongoose(schema1);
			} catch (err) {
				expect(err).toMatchObject(new Error('Seems you have a cyclic type definitions'));
			}
		});
	});

	describe('CreateMongooseEntity class method', () => {
		it("creates mongoose schema from given parsed entiti's schema", () => {
			const parseEntity = testEntity.getEntity('simple1');
			const mongooseEntity = testEntity.createMongooseEntity(parseEntity);
			expect(mongooseEntity.mongooseSchema).toBeInstanceOf(Schema);
		});
	});

	describe('createMongooseSchema separate function', () => {
		it("creates mongoose schema from given parsed entiti's schema", () => {
			const parseEntity = testEntity.getEntity('simple1');
			const mongooseSchema = createMongooseSchema(parseEntity);
			expect(mongooseSchema).toBeInstanceOf(Schema);
		});
	});

	describe('mongo collections test', () => {
		it('creates collection based on parsed schema and sets default value, both nested and non nested', async () => {
			const parseEntity = testEntity.getEntity('NonPrimitive');
			const mongooseSchema = createMongooseSchema(parseEntity);
			const mod = model('NonPrimitive', mongooseSchema);
			const created: any = await mod.create({});
			expect(created.prop1).toMatchObject({ prop1: 'prop1' });
			expect(created.prop3).toBe('prop3Value');
		});

		it('creates field with uuid generated value if value not given', async () => {
			const parseEntity = testEntity.getEntity('A');
			const mongooseSchema = createMongooseSchema(parseEntity);
			const mod = model('A', mongooseSchema);
			const created: any = await mod.create({});
			expect(created.a).toBeTruthy();
			expect(created.a.length).toBe(36);
		});

		it('creates field with uuid generated value if value given', async () => {
			const parseEntity = testEntity.getEntity('B');
			const mongooseSchema = createMongooseSchema(parseEntity);
			const mod = model('B', mongooseSchema);
			const created: any = await mod.create({ a: 'smt' });

			expect(created.a).toBeTruthy();
			expect(created.a.length).toBe(36);
			expect(created.a).not.toBe('smt');
		});

		it('throws error if tried to change uuid genereated value', async () => {
			try {
				const parseEntity = testEntity.getEntity('C');
				const mongooseSchema = createMongooseSchema(parseEntity);
				const mod = model('C', mongooseSchema);
				await mod.create({ id: 'id' });
				await mod.findOneAndUpdate({ id: 'id' }, { a: 'change' });
			} catch (err) {
				expect(err).toMatchObject(new Error('field a should be set once'));
			}
		});

		it('throws error if tried to change value of field which has "setonce" directive', async () => {
			try {
				const parseEntity = testEntity.getEntity('D');
				const mongooseSchema = createMongooseSchema(parseEntity);
				const mod = model('D', mongooseSchema);
				await mod.create({ a: '5d9eed316e1c0332c60e7629' });
				const aChange = { a: 'change', b: 'bVal' };
				await mod.findOneAndUpdate({ a: '5d9eed316e1c0332c60e7629' }, { ...aChange }, { new: true });
			} catch (err) {
				expect(err).toMatchObject(new Error('field a should be set once'));
			}
		});
	});
});
