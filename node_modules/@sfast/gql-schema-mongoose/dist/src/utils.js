"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var mongoose_1 = require("mongoose");
var lodash_1 = require("lodash");
var md5_1 = __importDefault(require("md5"));
var uuid_1 = require("uuid");
var gql_schema_parser_1 = require("@sfast/gql-schema-parser");
var constants_1 = require("./constants");
exports.getRowType = function (type) {
    switch (type) {
        case 'String':
            return 'String';
        case 'Int':
        case 'Float':
            return 'Number';
        case 'ID':
            return 'ObjectId';
        case 'Date':
            return 'Date';
        case 'Boolean':
            return 'Boolean';
        default:
            return 'String'; // need for enum parsing
    }
};
/**
 * hashes the value
 * @param value '@hash' directive value
 */
function hashValue(value) {
    return md5_1.default(value);
}
exports.hashValue = hashValue;
/**
 * Gets mongoose definition
 * @param field
 */
function getFieldMongooseDefinition(field) {
    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({ type: parseType(field) }, (!!field.default && { default: field.default })), (!!field.enum && { enum: field.enum.values })), (!!field.required && { required: true })), (!!field.unique && { unique: true })), (!!field.min && { min: field.min })), (!!field.max && { max: field.max })), (!!field.maxLength && { maxLength: field.maxLength })), (!!field.minLength && { minLength: field.minLength })), (!!field.trim && { trim: field.trim })), (!!field.uppercase && { uppercase: field.uppercase })), (!!field.lowercase && { lowercase: field.lowercase })), (!!field.collection && { collection: field.collection })), (!!field.hash && { set: hashValue })), (!!field.setonce && { setonce: field.setonce })), (!!field.uuid && { uuid: field.uuid }));
}
exports.getFieldMongooseDefinition = getFieldMongooseDefinition;
/**
 * Parses type of filed in schema
 * @param field
 */
function parseType(field) {
    var parsedType;
    // ** parses only primitive entity types
    parsedType = parseToMongooseType(field);
    if (Array.isArray(parsedType)) {
        // ** recursion for parsing array of user defined type
        parsedType = lodash_1.map(parsedType, function (elem) {
            if (typeof elem === 'object') {
                return lodash_1.mapValues(elem, function (value) {
                    return getFieldMongooseDefinition(value);
                });
            }
            else {
                return elem;
            }
        });
    }
    // ** recursion for parsing user defined type
    if (typeof parsedType === 'object' && !Array.isArray(parsedType)) {
        return lodash_1.mapValues(parsedType, function (value) {
            return getFieldMongooseDefinition(value);
        });
    }
    return parsedType;
}
/**
 * Parses graphql types to mongoose types
 * @param field - schema field
 */
function parseToMongooseType(field) {
    var type = field.type, list = field.list;
    var parsedType;
    if (type && lodash_1.get(type, 'kind') === 'union') {
        parsedType = 'Mixed';
    }
    else if (typeof type !== 'object') {
        parsedType = exports.getRowType(type);
    }
    else {
        parsedType = type;
    }
    if (gql_schema_parser_1.getFieldDirective(field, constants_1.DIRECTIVES.ObjectId)) {
        parsedType = 'ObjectId';
    }
    return list ? [parsedType] : parsedType;
}
exports.parseToMongooseType = parseToMongooseType;
function createSchema(schema, schemaClassType, directives) {
    if (schemaClassType === void 0) { schemaClassType = mongoose_1.Schema; }
    var _a, _b, _c, _d, _e, _f;
    delete schema._id;
    if (typeof ((_b = (_a = directives) === null || _a === void 0 ? void 0 : _a.mongo) === null || _b === void 0 ? void 0 : _b.timestamps) === 'object' && ((_d = (_c = directives) === null || _c === void 0 ? void 0 : _c.mongo) === null || _d === void 0 ? void 0 : _d.timestamps) !== null) {
        return new schemaClassType(schema, __assign({}, directives.mongo));
    }
    else if (((_f = (_e = directives) === null || _e === void 0 ? void 0 : _e.mongo) === null || _f === void 0 ? void 0 : _f.timestamps) === true) {
        return new schemaClassType(schema, { timestamps: true });
    }
    return new schemaClassType(schema);
}
exports.createSchema = createSchema;
function mongooseSchemaDefinition(schema, schemaClassType) {
    // ** type of is IEntitySchema cause during the parsing, it can be unparsed object: IEntitySchema, then it will be parsed
    if (schemaClassType === void 0) { schemaClassType = mongoose_1.Schema; }
    var parsedEntity = {};
    Object.values(schema).forEach(function (field) {
        var typeValue;
        var fieldMongooseDef = getFieldMongooseDefinition(field);
        var fieldType = fieldMongooseDef.type;
        // tslint:disable-next-line:variable-name
        var isFieldObjType = typeof fieldType === 'object' && !Array.isArray(fieldType);
        if (isFieldObjType) {
            typeValue = fieldType;
        }
        else if (Array.isArray(fieldType)) {
            typeValue = lodash_1.map(fieldType, function (elem) {
                return elem;
            });
        }
        else {
            typeValue = fieldMongooseDef.type;
        }
        var schemaData = isFieldObjType ? typeValue : __assign(__assign({}, fieldMongooseDef), { type: typeValue });
        // ** overwriting the right type
        parsedEntity[field.name] = schemaData;
    });
    return parsedEntity;
}
exports.mongooseSchemaDefinition = mongooseSchemaDefinition;
function createMongooseSchema(entity) {
    var mongoooseEntitySchema = mongooseSchemaDefinition(entity.schema);
    var mongooseSchema = createSchema(mongoooseEntitySchema, mongoose_1.Schema, entity.directives);
    mongooseSchema.plugin(customPlugin);
    return mongooseSchema;
}
exports.createMongooseSchema = createMongooseSchema;
function generateUuid() {
    return uuid_1.v4();
}
exports.generateUuid = generateUuid;
function customPlugin(schema) {
    // tslint:disable-next-line: only-arrow-functions
    var setUUid = function (next) {
        var _this = this;
        schema.eachPath(function (path, schemaType) {
            if (schemaType.options.uuid && !_this[path]) {
                _this[schemaType.path] = generateUuid();
            }
        });
        next();
    };
    var preUpdate = function (next) {
        var update = this.getUpdate();
        schema.eachPath(function (path, schemaType) {
            if (schemaType.options.uuid || schemaType.options.setonce) {
                var modified = lodash_1.has(update, "$set." + path) || lodash_1.has(update, path);
                if (modified) {
                    throw new Error("field " + path + " should be set once");
                }
            }
        });
        next();
    };
    // TODO :: please note query and document middlewares
    schema.pre('save', setUUid);
    schema.pre('update', preUpdate);
    schema.pre('updateOne', preUpdate);
    schema.pre('updateMany', preUpdate);
    schema.pre('findOneAndUpdate', preUpdate);
}
exports.customPlugin = customPlugin;
