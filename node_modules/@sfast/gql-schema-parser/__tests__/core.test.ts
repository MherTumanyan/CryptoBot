import gql from 'graphql-tag';

import { GraphEntityParser } from '../src';

const schema = gql`
	union UType = FullName | Name

	scalar Date

	enum EType {
		prop1
		prop2
	}

	input ISimpleType {
		prop1: String
		prop2: Boolean
	}

	type Extendable1 {
		ex1: Int
	}
	type Extendable2 {
		ex2: Int
	}

	# for testing directives
	input TestDirType @collection(value: "tetsdirtypes") @extends(value: "Extendable1") {
		prop1: String! @default(value: "prop1") @unique @hash @setonce @minlength(value: 4) @maxlength(value: 10)
		prop2: [Int] @required @min(value: 2) @max(value: 9) @uppercase
		# enum type
		prop3: EType
		# user defined type
		prop4: [ISimpleType]!
	}

	type TestDirType1 @extends(value: ["Extendable1", "Extendable2"]) {
		prop1: Date
		prop2: UType
	}
`;

describe('GraphEntityParser', () => {
	let parsedEntities: ChildOfGraphEntityParser;
	class ChildOfGraphEntityParser extends GraphEntityParser {
		public unions;
		public scalars;
		public enums;
		// public entities;
		constructor(gqlSchema) {
			super(gqlSchema);
			this.unions = this._unions;
			this.scalars = this._scalars;
			this.enums = this._enums;
			// this.entities = this._entities;
		}
	}

	beforeEach(() => {
		parsedEntities = new ChildOfGraphEntityParser(schema);
	});

	describe('_unions', () => {
		it('returns parsed union', () => {
			const parsedUnion = parsedEntities.unions;
			expect(parsedUnion.UType).toMatchObject({ name: 'UType', types: ['FullName', 'Name'] });
		});
	});

	describe('_scalars', () => {
		it('returns parsed scalar', () => {
			const parsedScalar = parsedEntities.scalars;
			expect(parsedScalar).toMatchObject({ Date: 'Date' });
		});
	});

	describe('_enums', () => {
		it('returns parsed enum', () => {
			const parsedEnum = parsedEntities.enums;
			expect(parsedEnum.EType).toMatchObject({ name: 'EType', values: ['prop1', 'prop2'] });
		});
	});

	describe('_entities', () => {
		it('returns parsed input as entity, checks defaults and given values(name, type)', () => {
			const ISimpleType = parsedEntities.entities.ISimpleType;

			// ** for defaults
			expect(ISimpleType.namespace).toBe('main');
			// tslint:disable-next-line: no-unused-expression
			expect(ISimpleType.collection).toBeUndefined;
			expect(ISimpleType.version).toBe('0.0.1');

			// ** check for given values
			expect(ISimpleType.schema).toMatchObject({
				prop1: {
					name: 'prop1',
					type: 'String'
				},
				prop2: {
					name: 'prop2',
					type: 'Boolean'
				}
			});
		});

		it('check for directives', () => {
			const TestDirType = parsedEntities.entities.TestDirType;
			// ** collection in entity
			expect(TestDirType.collection).toBe('tetsdirtypes');
			// ** check for directives in entity
			expect(TestDirType.directives).toMatchObject({
				collection: { value: 'tetsdirtypes' },
				extends: { value: 'Extendable1' }
			});

			const prop1Schema = TestDirType.schema.prop1;

			// ** check for given directives values in schema
			expect(prop1Schema.default).toBe('prop1');
			expect(prop1Schema.required).toBe(true);
			expect(prop1Schema.unique).toBe(true);
			expect(prop1Schema.trim).toBe(true);
			expect(prop1Schema.hash).toBe(true);
			expect(prop1Schema.minLength).toBe(4);
			expect(prop1Schema.maxLength).toBe(10);

			// ** check for schema directives
			expect(prop1Schema.directives).toMatchObject({
				default: { value: 'prop1' },
				unique: {},
				hash: {},
				setonce: {},
				minlength: { value: '4' },
				maxlength: { value: '10' }
			});

			const prop2Schema = TestDirType.schema.prop2;
			expect(prop2Schema.list).toBe(true);
			expect(prop2Schema.min).toBe(2);
			expect(prop2Schema.max).toBe(9);

			expect(prop2Schema.directives).toMatchObject({
				required: {},
				min: { value: '2' },
				max: { value: '9' }
			});

			const prop3Schema = TestDirType.schema.prop3;
			// ** enum check
			expect(prop3Schema.enum).toMatchObject({ name: 'EType', values: ['prop1', 'prop2'] });

			const prop4Schema = TestDirType.schema.prop4;

			// ** user defined type check
			expect(prop4Schema.type).toMatchObject({
				prop1: {
					name: 'prop1',
					type: 'String'
				},
				prop2: {
					name: 'prop2',
					type: 'Boolean'
				}
			});
			expect(prop4Schema.list).toBe(true);
			expect(prop4Schema.required).toBe(true);

			// ** check for extends directive
			expect(TestDirType.schema).toHaveProperty('ex1');

			const TestDirType1 = parsedEntities.entities.TestDirType1;

			// ** check for extends directive value is array
			// expect(TestDirType1.schema).toHaveProperty(['prop1', 'prop2', 'ex1', 'ex2']);// doesn't work, we can open issue if it isn't opened
			expect(TestDirType1.schema).toHaveProperty('ex1');
			expect(TestDirType1.schema).toHaveProperty('ex2');

			// ** check for given union type
			expect(TestDirType1.schema.prop2.type).toMatchObject({
				kind: 'union',
				name: 'UType',
				types: ['FullName', 'Name']
			});
			// ** check for given scalar type
			expect(TestDirType1.schema.prop1.type).toBe('Date');
		});
	});

	describe('getEntity', () => {
		it('gets parsed entity by given name', () => {
			const parsedEntity = parsedEntities.getEntity('ISimpleType');
			expect(parsedEntity.name).toBe('ISimpleType');
		});
	});
});
