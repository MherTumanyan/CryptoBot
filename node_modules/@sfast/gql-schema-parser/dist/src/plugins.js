"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var constants_1 = require("./constants");
var utils_1 = require("./utils");
// ** TODO::ARMINE this is type definition
exports.extractMongoPluginFields = function (parser, node, directiveArgs) {
    var _a, _b, _c, _d, _e, _f;
    var result = [utils_1.createFieldDefinition('_id', 'ID')];
    if (((_a = directiveArgs) === null || _a === void 0 ? void 0 : _a.timestamps) === true) {
        result.push(utils_1.createFieldDefinition('createdAt', 'Date'));
        result.push(utils_1.createFieldDefinition('updatedAt', 'Date'));
    }
    if (lodash_1.isObject((_b = directiveArgs) === null || _b === void 0 ? void 0 : _b.timestamps)) {
        result.push(utils_1.createFieldDefinition((_d = (_c = directiveArgs) === null || _c === void 0 ? void 0 : _c.timestamps) === null || _d === void 0 ? void 0 : _d.createdAt, 'Date'));
        result.push(utils_1.createFieldDefinition((_f = (_e = directiveArgs) === null || _e === void 0 ? void 0 : _e.timestamps) === null || _f === void 0 ? void 0 : _f.updatedAt, 'Date'));
    }
    return result;
};
var validateExtendsDirective = function (extendsDirectiveArgumentsArg) {
    // ** maybe move error handling as another function
    if (!extendsDirectiveArgumentsArg.hasOwnProperty(constants_1.EXTENDS.value)) {
        throw new Error("GQL::ERROR extends must have value argument - @extends({value: [\"User, Profile\"]}).");
    }
    if (extendsDirectiveArgumentsArg.hasOwnProperty(constants_1.EXTENDS.select) &&
        extendsDirectiveArgumentsArg.hasOwnProperty(constants_1.EXTENDS.reject)) {
        throw new Error("GQL::ERROR select and reject cant be given together, choose one of them.");
    }
    if (lodash_1.isArray(extendsDirectiveArgumentsArg.hasOwnProperty(constants_1.EXTENDS.value)) &&
        lodash_1.isArray(extendsDirectiveArgumentsArg.hasOwnProperty(constants_1.EXTENDS.select) ||
            lodash_1.isArray(extendsDirectiveArgumentsArg.hasOwnProperty(constants_1.EXTENDS.reject)))) {
        throw new Error('GQL::ERROR - if value is array select or reject must be boolean, maybe you can use fragments.');
    }
};
var fieldFragmentHasMatch = function (fieldFragments, fragmentArg) {
    fieldFragments = lodash_1.isArray(fieldFragments) ? fieldFragments : [fieldFragments];
    fragmentArg = lodash_1.isArray(fragmentArg) ? fragmentArg : [fragmentArg];
    return !!lodash_1.intersection(fieldFragments, fragmentArg).length;
};
// ** NOTE::predicate which will check if fieldDef is conforming the @extends request with select, reject, fragments
var predicate = function (fieldDef, extendsDirectiveArgsParam) {
    // ** select just directive, string, string[]
    // ** reject just directive, string, string[]
    // ** fragment = string, string[]
    var select = extendsDirectiveArgsParam.select, reject = extendsDirectiveArgsParam.reject, fragment = extendsDirectiveArgsParam.fragment;
    // ** TODO::AVAR here the predicate should be implemented
    if (extendsDirectiveArgsParam.select === undefined && extendsDirectiveArgsParam.reject === undefined) {
        return true;
    }
    var fieldFragmentDirectiveValue = null;
    if (utils_1.fieldHasDirective(fieldDef, constants_1.EXTENDS.fragment)) {
        var fragmentDirectiveArguments = utils_1.getArgumentsOfDirective(fieldDef, constants_1.EXTENDS.fragment);
        fieldFragmentDirectiveValue = utils_1.getArgValue(fragmentDirectiveArguments, constants_1.EXTENDS.value);
    }
    // case 1: select: ["fname"]
    // case 2: select: "fname"
    // case 3: select: true -> fragments
    // case 4: reject: ["fname"]
    // case 5: reject: "fname"
    // case 6: reject: true -> !fragments
    return ((lodash_1.isArray(select) && select.includes(fieldDef.name.value)) ||
        (lodash_1.isString(select) && select.split(',').includes(fieldDef.name.value)) ||
        (lodash_1.isBoolean(select) &&
            select &&
            fieldFragmentDirectiveValue &&
            fragment &&
            fieldFragmentHasMatch(fieldFragmentDirectiveValue, fragment)) ||
        (lodash_1.isArray(reject) && !reject.includes(fieldDef.name.value)) ||
        (lodash_1.isString(reject) && !reject.split(',').includes(fieldDef.name.value)) ||
        (lodash_1.isBoolean(reject) &&
            reject &&
            fieldFragmentDirectiveValue &&
            fragment &&
            !fieldFragmentHasMatch(fieldFragmentDirectiveValue, fragment)) ||
        (lodash_1.isBoolean(reject) && reject && !fieldFragmentDirectiveValue));
};
// ** TODO::ARMINE this is type definition  - IDirectiveArgType + more specifics
exports.extractExtendPluginFields = function (parser, node, extendsDirectiveArgs) {
    // console.log("GQL::extractExtendPluginFields");
    validateExtendsDirective(extendsDirectiveArgs);
    // ** Error handling finished :)
    var extendedTypeNamesArray = lodash_1.isArray(extendsDirectiveArgs.value)
        ? extendsDirectiveArgs.value
        : [extendsDirectiveArgs.value];
    var resultFields = [];
    // ** getting parent node with applied directives and filtering the result fields with current extend
    lodash_1.reduce(extendedTypeNamesArray, function (acc, typeName) {
        // ** TODO::AVAR::IMPORTANT here we'll need to filter based on hierarchy definition
        var tmpTypeDef = parser.getTypeDefinition(typeName);
        var parentNodeAST = parser.getASTWithGQLPluginsApplied(tmpTypeDef);
        lodash_1.each(parentNodeAST.fields, function (tmpTypeFieldItem) {
            if (predicate(tmpTypeFieldItem, extendsDirectiveArgs)) {
                if (node.kind === 'InputObjectTypeDefinition') {
                    acc.push(generateInputObjectDefinition(tmpTypeFieldItem, parser));
                }
                else if (node.kind === 'ObjectTypeDefinition') {
                    acc.push(tmpTypeFieldItem);
                }
            }
        });
        return acc;
    }, resultFields);
    return resultFields;
};
exports.gqlDefaultPlugins = [
    {
        name: 'extends',
        extractFields: exports.extractExtendPluginFields
    },
    {
        name: 'mongo',
        extractFields: exports.extractMongoPluginFields
    }
];
function generateInputObjectDefinition(objectTypeDef, parser) {
    var _a;
    if (((_a = objectTypeDef.type) === null || _a === void 0 ? void 0 : _a.kind) === 'NamedType' && !constants_1.primitives.includes(objectTypeDef.type.name.value)) {
        if (parser.getTypeDefinition(objectTypeDef.type.name.value)) {
            // TODO:: check if its a field definition and only then try to generate an input
            var fieldTypeDefinition = parser.getTypeDefinition(objectTypeDef.type.name.value);
            var inputType = utils_1.convertTypeToInputDefinition(fieldTypeDefinition);
            if (inputType.kind === 'InputObjectTypeDefinition') {
                parser.enhanceSchemaWithTypeDefinition(inputType);
                console.log('AVAR::generateInputObjectDefinition ', inputType.kind);
            }
            return __assign(__assign({}, objectTypeDef), { type: __assign(__assign({}, objectTypeDef.type), { name: __assign(__assign({}, objectTypeDef.type.name), { value: inputType.name.value }) }) });
        }
    }
    return objectTypeDef;
}
exports.generateInputObjectDefinition = generateInputObjectDefinition;
