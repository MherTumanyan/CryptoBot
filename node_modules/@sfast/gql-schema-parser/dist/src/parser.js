"use strict";
/**
 * @module Parser
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var lodash_1 = require("lodash");
var constants_1 = require("./constants");
var utils_1 = require("./utils");
var plugins_1 = require("./plugins");
var GraphEntityParser = /** @class */ (function () {
    // tslint:disable-next-line: member-ordering
    function GraphEntityParser(graphNode, options) {
        this._entities = {};
        this._enums = {};
        this._unions = {};
        this._scalars = {};
        this._updatedGraphNode = { kind: 'Document', definitions: [] };
        this._typeDefinitionMap = {};
        // ** state to store the parsing status of the entity (i.e catch cyclic parse occurences)
        this._entityParsingStates = {};
        this._options = __assign({ plugins: __spread(plugins_1.gqlDefaultPlugins) }, options);
        this._initalGraphNode = graphNode;
        this._updatedGraphNode.definitions = __spread(graphNode.definitions);
        this.preparePlugins();
        // ** filtring and scanning the definitions and storing them like {typeName: type}
        this.parseDefinitions();
    }
    Object.defineProperty(GraphEntityParser.prototype, "entities", {
        /**
         * @returns parsed entities
         */
        get: function () {
            return this._entities;
        },
        enumerable: true,
        configurable: true
    });
    GraphEntityParser.prototype.enhanceSchemaWithTypeDefinition = function (definition) {
        this._updatedGraphNode.definitions.push(definition);
    };
    // **** Some Plugin functionality - START
    GraphEntityParser.prototype.preparePlugins = function () {
        // ** maybe we'll have initialization for them
        var accResult = {};
        this._plugins = lodash_1.reduce(this._options.plugins, function (acc, pluginItem) {
            // console.log("GQL::pluginItem", pluginItem);
            if (pluginItem && pluginItem.name) {
                acc[pluginItem.name] = pluginItem;
            }
            return acc;
        }, accResult);
    };
    GraphEntityParser.prototype.hasPlugin = function (name) {
        return !!this._plugins[name];
    };
    GraphEntityParser.prototype.getPlugin = function (name) {
        return this._plugins[name];
    };
    // **** Plugin functionality - END
    GraphEntityParser.prototype.getEntity = function (entityName) {
        return this._entities[entityName];
    };
    // ** This is Object or Input type definition
    GraphEntityParser.prototype.getASTWithGQLPluginsApplied = function (node) {
        // ** create new node with only readonly 'fields'
        var _this = this;
        var currentNodeFields = lodash_1.reduce(node.fields, function (acc, nodeFieldItem) {
            if (!utils_1.fieldHasDirective(nodeFieldItem, 'ignore')) {
                acc.push(nodeFieldItem);
            }
            return acc;
        }, []);
        var newNode = __assign(__assign({}, node), { fields: __spread(currentNodeFields) });
        // ** ececuting extractFields() for every plugin
        lodash_1.forOwn(this.parseDirectiveDefinitions(node), function (value, key) {
            // ** if we have a plugin with directive name
            if (_this.hasPlugin(key)) {
                var plugin = _this.getPlugin(key);
                var extractedPluginFields = plugin.extractFields(_this, node, value);
                // console.log(`GQL::parseNode extractedPluginFields`, extractedPluginFields);
                newNode.fields = __spread(extractedPluginFields, newNode.fields);
                // ** remove the type directive after processing it
                var withoutPluginDirective = lodash_1.reduce(newNode.directives || [], function (acc, item) {
                    if (item.name.value !== key) {
                        acc.push(item);
                    }
                    return acc;
                }, []);
                newNode.directives = __spread(withoutPluginDirective);
            }
        });
        return newNode;
        // const filteredNode = {...newNode, fields: filterFieldsFromDirectives(newNode.fields)}
        // return filteredNode as SchemaTypeDefinitionNode;
    };
    // ** this gets the final schema as a DocumentNode?? with applied changes for AST
    GraphEntityParser.prototype.getSchema = function () {
        this._updatedGraphNode = this.visitSchema();
        this.parseDefinitions();
        return this._updatedGraphNode;
    };
    GraphEntityParser.prototype.printSchema = function (schema) {
        return graphql_1.print(schema);
    };
    /**
     * Gets GraphQL definition of given type
     * @param typeName - name of type
     *
     */
    GraphEntityParser.prototype.getTypeDefinition = function (typeName) {
        switch (this._typeDefinitionMap[typeName]) {
            case 'ObjectTypeDefinition':
                return utils_1.findTypeDef(typeName, this._objectDefinitions);
            case 'InputObjectTypeDefinition':
                return utils_1.findTypeDef(typeName, this._inputDefinitions);
            case 'UnionTypeDefinition':
                return utils_1.findTypeDef(typeName, this._unionDefinitions);
            case 'ScalarTypeDefinition':
                return utils_1.findTypeDef(typeName, this._scalarDefinitions);
            default:
                throw new Error("Can not find definition of " + typeName);
        }
    };
    /**
     * Returns an array which contains all of the type names in the chain of inheritance from left(current) to parents on the left
     * With 'deep' arg you can control if you need all extends across the parent chain or only the direct parents
     * @param typeNameArg
     * @param deep
     */
    GraphEntityParser.prototype.getTypeChain = function (typeNameArg, deep) {
        var _this = this;
        if (deep === void 0) { deep = false; }
        var typeDefNode = this.getTypeDefinition(typeNameArg);
        var extendsDirectiveValue = utils_1.getNodeDirectiveValue(typeDefNode, constants_1.DIRECTIVES.extends);
        if (!extendsDirectiveValue) {
            return [typeNameArg];
        }
        var typeChain = [typeNameArg];
        var typeNames = lodash_1.isArray(extendsDirectiveValue)
            ? extendsDirectiveValue
            : [extendsDirectiveValue];
        lodash_1.reduce(typeNames, function (acc, typeName) {
            var typeNameTmp = typeof typeName === 'object' ? typeName.value : typeName;
            var typesInChainTmp = deep ? _this.getTypeChain(typeNameTmp) : [typeNameTmp];
            if (typesInChainTmp.length > 0) {
                acc.push.apply(acc, __spread(typesInChainTmp));
            }
            return acc;
        }, typeChain);
        return typeChain;
    };
    /**
     * Returns the fields with or without the directives
     * @param typeName
     * @param removeDirectivesFlag
     */
    GraphEntityParser.prototype.getTypeOwnFields = function (typeName, removeDirectivesFlag) {
        if (removeDirectivesFlag === void 0) { removeDirectivesFlag = false; }
        var typeDefinition = this.getTypeDefinition(typeName);
        // ** NOTE:: typeDefinition.fields is readonly array, so we need to create new array
        return !removeDirectivesFlag
            ? __spread(typeDefinition.fields) : __spread(utils_1.removeDirectivesFromFields(typeDefinition.fields));
    };
    /**
     * Checks if definition of field type exists (in _typeDefinitionMap)
     * @param nameOfType - name of field type(it can be both primitive type and user defined type)
     * @param typeDefinition - kind of definition (e.g. "ObjectTypeDefinition", "InputObjectTypeDefinition")
     *
     */
    GraphEntityParser.prototype.assertDefinitionInSchema = function (nameOfType, typeDefinition) {
        if (typeDefinition) {
            // ** if typeDefinition is not array, create array from it
            var typeDefinitionList = lodash_1.isArray(typeDefinition)
                ? typeDefinition
                : [typeDefinition]; // typeDefinitions is not assignable to string[] => used <string[]> for assignability
            var fieldType = this._typeDefinitionMap[nameOfType];
            return !!(fieldType && typeDefinitionList.includes(fieldType));
        }
        return !!this._typeDefinitionMap[nameOfType];
    };
    /**
     * Parses union definition to (name, types) object, if some types are user defined types, doesn't parse them -> shallow parsing
     * @param unionDefinitions - array of union definitions
     */
    GraphEntityParser.prototype.parseUnionDefinitions = function (unionDefinitions) {
        return lodash_1.reduce(unionDefinitions, function (parsedUnions, unionDefNode) {
            if (!lodash_1.isArray(unionDefNode.types)) {
                throw new Error('Union parsing had some unexpected error, probably the type is undefined');
            }
            var unionDefParsed = {
                name: unionDefNode.name.value,
                types: unionDefNode.types.map(function (val) { return val.name.value; })
            };
            parsedUnions[unionDefParsed.name] = unionDefParsed;
            return parsedUnions;
        }, {});
    };
    /**
     * Parses scalar definitions
     * @param scalarDefinitions - definitions of scalars
     */
    GraphEntityParser.prototype.parseScalarDefinitions = function (scalarDefinitions) {
        return lodash_1.reduce(scalarDefinitions, function (parsedScalars, scalarDefNode) {
            parsedScalars[scalarDefNode.name.value] = scalarDefNode.name.value;
            return parsedScalars;
        }, {});
    };
    /**
     * Parses enum definitions
     * @param enumDefinitions - definitions of enum types
     */
    GraphEntityParser.prototype.parseEnumDefinitions = function (enumDefinitions) {
        return lodash_1.reduce(enumDefinitions, function (parsedEnums, enumDefNode) {
            if (!lodash_1.isArray(enumDefNode.values) || enumDefNode.values.length <= 0) {
                throw new Error('Enum definition should have at least one field');
            }
            var enumDefParsed = {
                name: enumDefNode.name.value,
                values: enumDefNode.values.map(function (val) { return val.name.value; })
            };
            parsedEnums[enumDefParsed.name] = enumDefParsed;
            return parsedEnums;
        }, {});
    };
    /**
     * Parses array of definitions
     * @param typeDefinitions - array of definitions
     */
    GraphEntityParser.prototype.parseEntityDefinitions = function (typeDefinitions) {
        var _this = this;
        return lodash_1.reduce(typeDefinitions, function (parsedEntities, typeDefNode) {
            var entityDef = _this.parseEntityDefinition(typeDefNode);
            if (!entityDef) {
                return parsedEntities;
            }
            var entityName = typeDefNode.name.value;
            parsedEntities[entityName] = entityDef;
            return parsedEntities;
        }, {});
    };
    /**
     * Parses AST definiton of type
     * @param typeDefNode definition of node(user defined type)
     *
     */
    GraphEntityParser.prototype.parseEntityDefinition = function (typeDefNode, deep) {
        var _this = this;
        if (deep === void 0) { deep = false; }
        var entityName = typeDefNode.name.value;
        if (this._entityParsingStates[entityName]) {
            throw new Error("Seems you have a cyclic type definitions");
        }
        // ** setting the parsing status to true
        this._entityParsingStates[entityName] = true;
        var typesInChain = this.getTypeChain(entityName, deep);
        var fieldsInChain = lodash_1.reduce(typesInChain, function (acc, typeInChainName) {
            acc.push.apply(acc, __spread(_this.getTypeOwnFields(typeInChainName)));
            return acc;
        }, new Array());
        var entityDef = {
            namespace: utils_1.getNodeDirectiveValue(typeDefNode, constants_1.DIRECTIVES.namespace, 'main'),
            name: entityName,
            collection: utils_1.getNodeDirectiveValue(typeDefNode, constants_1.DIRECTIVES.collection),
            version: utils_1.getNodeDirectiveValue(typeDefNode, constants_1.DIRECTIVES.version, '0.0.1'),
            schema: this.parseFieldDefinitions(fieldsInChain),
            directives: this.parseDirectiveDefinitions(typeDefNode)
        };
        delete this._entityParsingStates[entityName];
        return entityDef;
    };
    /**
     * Parses Field definitions
     * @param fieldDefNodes - field definition nodes
     */
    GraphEntityParser.prototype.parseFieldDefinitions = function (fieldDefNodes) {
        var _this = this;
        return lodash_1.reduce(fieldDefNodes, function (parsedFieldDefinitions, fieldDefNode) {
            var fieldName = fieldDefNode.name.value;
            var fieldDef = _this.parseFieldDefinition(fieldDefNode);
            if (!fieldDef) {
                return parsedFieldDefinitions;
            }
            parsedFieldDefinitions[fieldName] = fieldDef;
            return parsedFieldDefinitions;
        }, {});
    };
    /**
     * Parses definition of field
     * @param fieldDef definition of field
     *
     */
    GraphEntityParser.prototype.parseFieldDefinition = function (fieldDef) {
        if (utils_1.definitionHasDirective(fieldDef, constants_1.DIRECTIVES.ignore)) {
            return;
        }
        // ** gets the leaf type of field
        var fieldNamedType = utils_1.getNamedType(fieldDef.type);
        // ** gets the leaf name of field type -  e.g [Person!]! -> "Person"
        var fieldType = fieldNamedType.name.value;
        var fieldTypeResult = fieldType;
        // ** get field name
        var fieldName = utils_1.getNameField(fieldDef);
        // ** if its not a standard type then we should have it defined e.g type, enum, scalar, union
        if (!utils_1.isBuiltInType(fieldType) && !this.assertDefinitionInSchema(fieldType)) {
            throw new Error("Definition for " + fieldType + " is missing");
        }
        // ** if the field type is gql type or input definition
        if (this.assertDefinitionInSchema(fieldType, ['ObjectTypeDefinition', 'InputObjectTypeDefinition'])) {
            var entityDef = this._entities[fieldType]
                ? this._entities[fieldType]
                : this.parseEntityDefinition(this.getTypeDefinition(fieldType));
            fieldTypeResult = entityDef.schema;
        }
        // ** for union types we are just returining union type names
        if (this.assertDefinitionInSchema(fieldType, 'UnionTypeDefinition')) {
            // tslint:disable-next-line: no-object-literal-type-assertion
            fieldTypeResult = __assign({ kind: 'union' }, this._unions[fieldType]);
        }
        // ** TODO::Armine add logic for other scalars
        if (this.assertDefinitionInSchema(fieldType, 'ScalarTypeDefinition')) {
            if (fieldType === 'Date') {
                fieldTypeResult = this._scalars[fieldType];
            }
        }
        var schemaFieldDef = {
            name: fieldName,
            type: fieldTypeResult,
            default: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.default),
            // ** if enum
            enum: fieldType in this._enums ? this._enums[fieldType] : undefined,
            list: utils_1.isFieldArray(fieldDef),
            required: utils_1.isRequiredField(fieldDef) || utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.required, false),
            unique: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.unique, false),
            optional: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.optional, false),
            setonce: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.setonce, false),
            uuid: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.uuid, false),
            min: utils_1.getNodeDirectiveNumericValue(fieldDef, constants_1.DIRECTIVES.min),
            max: utils_1.getNodeDirectiveNumericValue(fieldDef, constants_1.DIRECTIVES.max),
            maxLength: utils_1.getNodeDirectiveNumericValue(fieldDef, constants_1.DIRECTIVES.maxLength),
            minLength: utils_1.getNodeDirectiveNumericValue(fieldDef, constants_1.DIRECTIVES.minLength),
            trim: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.trim, true),
            uppercase: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.uppercase, false),
            lowercase: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.lowercase, false),
            hash: utils_1.getNodeDirectiveValue(fieldDef, constants_1.DIRECTIVES.hash, false),
            directives: this.parseDirectiveDefinitions(fieldDef)
        };
        // console.log(`GQL::parseFieldDefinition:: for '${fieldType}'`, schemaFieldDef);
        return schemaFieldDef;
    };
    /**
     * Parses directives of given node
     * @param typeDefNode - definition of node
     */
    // ** i.e {directiveName: {argName: argValue}}
    GraphEntityParser.prototype.parseDirectiveDefinitions = function (typeDefNode) {
        var accDefinitions = {};
        if (!lodash_1.isArray(typeDefNode.directives) || typeDefNode.directives.length === 0) {
            return accDefinitions;
        }
        return lodash_1.reduce(typeDefNode.directives, function (acc, directiveDefinition) {
            var directiveName = directiveDefinition.name.value;
            acc[directiveName] = utils_1.getDirectiveArguments(directiveDefinition.arguments);
            return acc;
        }, accDefinitions);
    };
    /**
     * DFS in AST treee
     * @returns { DocumentNode } upadated Schema
     */
    GraphEntityParser.prototype.visitSchema = function () {
        var _this = this;
        return graphql_1.visit(this._updatedGraphNode, {
            enter: function (node, key, parent, path, ancestors) {
                if (node.kind === 'ObjectTypeDefinition' || node.kind === 'InputObjectTypeDefinition') {
                    return _this.getASTWithGQLPluginsApplied(node);
                }
            }
        });
    };
    /**
     * filtring and scanning the definitions and storing them like {typeName: type}
     */
    GraphEntityParser.prototype.parseDefinitions = function () {
        this._typeDefinitionNodes = utils_1.filterTypeDefinitions(this._updatedGraphNode.definitions);
        this._typeDefinitionMap = lodash_1.reduce(this._typeDefinitionNodes, function (acc, def) {
            // ** storing the name and the type string value
            acc[def.name.value] = def.kind;
            return acc;
        }, {});
        // TODO::ARMINE - this zibilanoc could be potentialy changed with visit logic
        this._objectDefinitions = lodash_1.filter(this._typeDefinitionNodes, {
            kind: 'ObjectTypeDefinition'
        });
        this._enumDefinitions = lodash_1.filter(this._typeDefinitionNodes, {
            kind: 'EnumTypeDefinition'
        });
        this._unionDefinitions = lodash_1.filter(this._typeDefinitionNodes, {
            kind: 'UnionTypeDefinition'
        });
        this._scalarDefinitions = lodash_1.filter(this._typeDefinitionNodes, {
            kind: 'ScalarTypeDefinition'
        });
        this._inputDefinitions = lodash_1.filter(this._typeDefinitionNodes, {
            kind: 'InputObjectTypeDefinition'
        });
        // ** TODO union
        this._unions = this.parseUnionDefinitions(this._unionDefinitions);
        // ** TODO scalar
        this._scalars = this.parseScalarDefinitions(this._scalarDefinitions);
        // ** TODO enum
        this._enums = this.parseEnumDefinitions(this._enumDefinitions);
        this._entities = this.parseEntityDefinitions(__spread(this._objectDefinitions, this._inputDefinitions));
    };
    return GraphEntityParser;
}());
exports.GraphEntityParser = GraphEntityParser;
