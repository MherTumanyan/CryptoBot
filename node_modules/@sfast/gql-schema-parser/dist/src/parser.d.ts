/**
 * @module Parser
 */
import { DocumentNode, ASTNode } from 'graphql';
import { IEntityDefinition, IEnumDefinition, IUnionDefinition, SchemaFieldDefinitionsNode, SchemaTypeDefinitionNode, TypeDefinitionsNode, ChangeableSchemaType, IGQLPlugin, CustomInputObjectTypeDef } from './types';
declare class GraphEntityParser {
    /**
     * @returns parsed entities
     */
    get entities(): Record<string, IEntityDefinition>;
    protected _options?: Record<string, any>;
    protected _plugins: Record<string, IGQLPlugin>;
    protected _entities: Record<string, IEntityDefinition>;
    protected _enums: Record<string, IEnumDefinition>;
    protected _unions: Record<string, IUnionDefinition>;
    protected _scalars: Record<string, string>;
    protected _initalGraphNode: DocumentNode;
    protected _updatedGraphNode: ChangeableSchemaType;
    private _typeDefinitionNodes;
    private _objectDefinitions;
    private _enumDefinitions;
    private _unionDefinitions;
    private _inputDefinitions;
    private _scalarDefinitions;
    private _typeDefinitionMap;
    private _entityParsingStates;
    constructor(graphNode: DocumentNode, options?: Record<string, any>);
    enhanceSchemaWithTypeDefinition(definition: CustomInputObjectTypeDef | TypeDefinitionsNode): void;
    preparePlugins(): void;
    hasPlugin(name: string): boolean;
    getPlugin(name: string): IGQLPlugin;
    getEntity(entityName: string): IEntityDefinition;
    getASTWithGQLPluginsApplied(node: SchemaTypeDefinitionNode): SchemaTypeDefinitionNode;
    getSchema(): DocumentNode;
    printSchema(schema: ASTNode): string;
    /**
     * Gets GraphQL definition of given type
     * @param typeName - name of type
     *
     */
    getTypeDefinition(typeName: string): TypeDefinitionsNode;
    /**
     * Returns an array which contains all of the type names in the chain of inheritance from left(current) to parents on the left
     * With 'deep' arg you can control if you need all extends across the parent chain or only the direct parents
     * @param typeNameArg
     * @param deep
     */
    getTypeChain(typeNameArg: string, deep?: boolean): string[];
    /**
     * Returns the fields with or without the directives
     * @param typeName
     * @param removeDirectivesFlag
     */
    getTypeOwnFields(typeName: string, removeDirectivesFlag?: boolean): SchemaFieldDefinitionsNode[];
    /**
     * Checks if definition of field type exists (in _typeDefinitionMap)
     * @param nameOfType - name of field type(it can be both primitive type and user defined type)
     * @param typeDefinition - kind of definition (e.g. "ObjectTypeDefinition", "InputObjectTypeDefinition")
     *
     */
    private assertDefinitionInSchema;
    /**
     * Parses union definition to (name, types) object, if some types are user defined types, doesn't parse them -> shallow parsing
     * @param unionDefinitions - array of union definitions
     */
    private parseUnionDefinitions;
    /**
     * Parses scalar definitions
     * @param scalarDefinitions - definitions of scalars
     */
    private parseScalarDefinitions;
    /**
     * Parses enum definitions
     * @param enumDefinitions - definitions of enum types
     */
    private parseEnumDefinitions;
    /**
     * Parses array of definitions
     * @param typeDefinitions - array of definitions
     */
    private parseEntityDefinitions;
    /**
     * Parses AST definiton of type
     * @param typeDefNode definition of node(user defined type)
     *
     */
    private parseEntityDefinition;
    /**
     * Parses Field definitions
     * @param fieldDefNodes - field definition nodes
     */
    private parseFieldDefinitions;
    /**
     * Parses definition of field
     * @param fieldDef definition of field
     *
     */
    private parseFieldDefinition;
    /**
     * Parses directives of given node
     * @param typeDefNode - definition of node
     */
    private parseDirectiveDefinitions;
    /**
     * DFS in AST treee
     * @returns { DocumentNode } upadated Schema
     */
    private visitSchema;
    /**
     * filtring and scanning the definitions and storing them like {typeName: type}
     */
    private parseDefinitions;
}
export { GraphEntityParser };
