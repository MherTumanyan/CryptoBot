"use strict";
/**
 * @module Utils
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var lodash_1 = require("lodash");
var constants_1 = require("./constants");
exports.isRequiredField = function (field) { return field.type.kind === 'NonNullType'; };
exports.isFieldArray = function (field) {
    return field.type.kind === 'ListType' || lodash_1.get(field, 'type.type.kind') === 'ListType';
};
exports.isUniqueDirective = function (directiveName) { return directiveName === constants_1.DIRECTIVES.unique; };
//  ** definitions
exports.builtinTypes = ['String', 'Float', 'Int', 'Boolean', 'ID'];
/**
 * Nested visitor for a type node to get to the final NamedType
 *
 * @param {TypeNode} type Type node to get NamedTypeNode for
 * @returns {NamedTypeNode} The found NamedTypeNode
 */
function getNamedType(type) {
    if (type.kind === 'NamedType') {
        return type;
    }
    else {
        return getNamedType(type.type);
    }
}
exports.getNamedType = getNamedType;
/**
 * Gets the name of field definition
 * @param fieldDef - Definition of field
 */
function getNameField(fieldDef) {
    return fieldDef.name.value;
}
exports.getNameField = getNameField;
/**
 * Filter relevant definitions from schema
 *
 * @param definitions - All definitions from a schema
 * @returns - Relevant type definitions
 */
function filterTypeDefinitions(definitions) {
    var validKinds = [
        'DirectiveDefinition',
        'ScalarTypeDefinition',
        'ObjectTypeDefinition',
        'InterfaceTypeDefinition',
        'EnumTypeDefinition',
        'UnionTypeDefinition',
        'InputObjectTypeDefinition'
    ];
    return definitions.filter(function (d) { return lodash_1.includes(validKinds, d.kind); });
}
exports.filterTypeDefinitions = filterTypeDefinitions;
/**
 * Checks if the node has the directive
 * @param typeDefinition - definition of type
 * @param directiveName - name of directive
 */
function definitionHasDirective(typeDefinition, directiveName) {
    return !!lodash_1.find(typeDefinition.directives, function (directive) { return directive.name.value === directiveName; });
}
exports.definitionHasDirective = definitionHasDirective;
/**
 * Casts value of directive
 * @param directiveValue - value of directive
 */
exports.castValue = function (directiveValue) {
    // ReadonlyArray<ValueNode> |
    var kind = directiveValue.kind, value = directiveValue.value, values = directiveValue.values;
    switch (kind) {
        case 'StringValue':
            return value;
        case 'IntValue':
            return value && parseInt(value, 10); // maybe return number need to check
        default:
            return value || values;
    }
};
/**
 *
 * @param nodeDef - definition of field or node(entity)
 * @param directiveName - name of directive
 * @param defaultValue - default value of directive
 */
function getNodeDirectiveValue(nodeDef, directiveName, defaultValue) {
    // console.log(`GQL::getNodeDirectiveValue ${directiveName}`,  nodeDef);
    var directiveNodeFound = lodash_1.find(nodeDef.directives, function (directive) { return directive.name.value === directiveName; });
    if (!directiveNodeFound) {
        return defaultValue || undefined;
    }
    // ** NOTE - argument should always be []
    if (!directiveNodeFound.arguments ||
        (lodash_1.isArray(directiveNodeFound.arguments) && directiveNodeFound.arguments.length === 0)) {
        return defaultValue || !!directiveNodeFound;
    }
    // ** ValueNode
    var directiveValue = directiveNodeFound.arguments[0].value;
    var result = (directiveValue && exports.castValue(directiveValue)) || defaultValue;
    // console.log(`GQL::getNodeDirectiveValue ${directiveName} , result = `,  result);
    return result;
}
exports.getNodeDirectiveValue = getNodeDirectiveValue;
function getNodeDirectiveNumericValue(nodeDef, directiveName, defaultValue) {
    var value = getNodeDirectiveValue(nodeDef, directiveName, defaultValue);
    try {
        if (value) {
            return parseInt(value, 10);
        }
    }
    catch (err) {
        throw new Error("Can't parse numeric value from " + value);
    }
}
exports.getNodeDirectiveNumericValue = getNodeDirectiveNumericValue;
/**
 * Checks if type is builtin type
 * @param typeName - name of type
 */
function isBuiltInType(typeName) {
    return exports.builtinTypes.includes(typeName);
}
exports.isBuiltInType = isBuiltInType;
/**
 * Finds definition of given typeName from given definitions
 * @param typeName
 * @param definitions
 */
function findTypeDef(typeName, definitions) {
    return lodash_1.find(definitions, function (def) { return def.name.value === typeName; });
}
exports.findTypeDef = findTypeDef;
// ** i.e {argName: argValue}
function getDirectiveArguments(args) {
    var directiveArguments = {};
    lodash_1.each(args, function (arg) {
        var argName = arg.name.value;
        // ** excluded types which don't have value property
        // ** TODO add implementation for nodes which dont have value property
        var argValue = arg.value;
        directiveArguments[argName] = parseArgValue(argValue);
    });
    return directiveArguments;
}
exports.getDirectiveArguments = getDirectiveArguments;
// ** TODO::AVAR fix type - argValue is ValueNode
function parseArgValue(argValue) {
    var _a, _b;
    if ((_a = argValue) === null || _a === void 0 ? void 0 : _a.value) {
        return argValue.value;
    }
    if (argValue.kind === 'ListValue') {
        return argValue.values.reduce(function (arrOfValues, value) {
            arrOfValues.push(value.value);
            return arrOfValues;
        }, []);
    }
    if (((_b = argValue) === null || _b === void 0 ? void 0 : _b.kind) === 'ObjectValue') {
        return argValue.fields.reduce(function (acc, field) {
            acc[field.name.value] = field.value.value;
            return acc;
        }, {});
    }
}
exports.parseArgValue = parseArgValue;
exports.getFieldDirective = function (field, directiveName) {
    var directives = field.directives;
    // ** checks object emptiness
    if (Object.entries(directives).length > 0 && directives.constructor === Object) {
        if (directiveName in directives) {
            return directives[directiveName];
        }
    }
};
// ** check if directive exists in SchemaOrFieldDefinitionNode
function fieldHasDirective(node, directiveName) {
    var directives = lodash_1.filter(node.directives, function (directive) {
        return directive.name.value === directiveName;
    });
    return !!directives.length;
}
exports.fieldHasDirective = fieldHasDirective;
// ** get arguments of directive => {argName: value}
function getArgumentsOfDirective(node, directiveName) {
    var directiveNode = lodash_1.find(node.directives, function (directive) { return directive.name.value === directiveName; });
    if (!directiveNode) {
        return {};
    }
    return lodash_1.reduce(directiveNode.arguments, function (acc, argNode) {
        var _a, _b;
        // ** arg.value is part of AST
        if (((_b = (_a = argNode) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.value) !== undefined) {
            acc[argNode.name.value] = argNode.value;
        }
        return acc;
    }, {});
}
exports.getArgumentsOfDirective = getArgumentsOfDirective;
// ** check if arg exists in arguments array of directive
// ** TODO::TYPE
function isArgExistsInDirective(args, argName) {
    return args.hasOwnProperty(argName);
}
exports.isArgExistsInDirective = isArgExistsInDirective;
// ** get value or values of given argument from arguments of directive
// TODO::ARMINE  fix any-s, 'args' is Record<string, ValueNode>
function getArgValue(args, argName) {
    var _a, _b;
    if ((_a = args[argName]) === null || _a === void 0 ? void 0 : _a.value) {
        return args[argName].value;
    }
    else if ((_b = args[argName]) === null || _b === void 0 ? void 0 : _b.values) {
        return args[argName].values.reduce(function (arrOfValues, value) {
            arrOfValues.push(value.value);
            return arrOfValues;
        }, []);
    }
}
exports.getArgValue = getArgValue;
function removeDirectivesFromFields(fields) {
    return fields.map(function (field) {
        var directives = field.directives, newField = __rest(field, ["directives"]);
        return newField;
    });
}
exports.removeDirectivesFromFields = removeDirectivesFromFields;
function createFieldDefinition(name, type) {
    return {
        kind: 'FieldDefinition',
        name: {
            kind: 'Name',
            value: name
        },
        arguments: [],
        type: {
            kind: 'NamedType',
            name: {
                kind: 'Name',
                value: type
            }
        },
        directives: []
    };
}
exports.createFieldDefinition = createFieldDefinition;
function convertTypeToInputDefinition(definition) {
    if (definition.kind === 'ObjectTypeDefinition') {
        var inputName = __assign(__assign({}, definition.name), { value: definition.name.value + 'Input' });
        return __assign(__assign({}, definition), { kind: 'InputObjectTypeDefinition', name: inputName, fields: definition.fields });
    }
    return definition;
}
exports.convertTypeToInputDefinition = convertTypeToInputDefinition;
function removeDirectivesFromFieldDefinition(fieldDefinition) {
    return __assign(__assign({}, fieldDefinition), { directives: [] });
}
exports.removeDirectivesFromFieldDefinition = removeDirectivesFromFieldDefinition;
