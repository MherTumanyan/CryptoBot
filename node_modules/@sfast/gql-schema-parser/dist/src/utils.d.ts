/**
 * @module Utils
 */
import { ArgumentNode, DefinitionNode, ListValueNode, NamedTypeNode, TypeNode, ValueNode } from 'graphql';
import { IDirectiveArgType, IDirectiveValueNode, NodeDirectiveValueType, SchemaFieldDefinitionsNode, SchemaOrFieldDefinitionNode, TypeDefinitionsNode, ValidDefinitionNode, IEntitySchemaField, CustomInputObjectTypeDef } from './types';
export declare const isRequiredField: (field: SchemaFieldDefinitionsNode) => boolean;
export declare const isFieldArray: (field: SchemaFieldDefinitionsNode) => boolean;
export declare const isUniqueDirective: (directiveName: string) => boolean;
export declare const builtinTypes: string[];
/**
 * Nested visitor for a type node to get to the final NamedType
 *
 * @param {TypeNode} type Type node to get NamedTypeNode for
 * @returns {NamedTypeNode} The found NamedTypeNode
 */
export declare function getNamedType(type: TypeNode): NamedTypeNode;
/**
 * Gets the name of field definition
 * @param fieldDef - Definition of field
 */
export declare function getNameField(fieldDef: SchemaFieldDefinitionsNode): string;
/**
 * Filter relevant definitions from schema
 *
 * @param definitions - All definitions from a schema
 * @returns - Relevant type definitions
 */
export declare function filterTypeDefinitions(definitions: ReadonlyArray<DefinitionNode>): ValidDefinitionNode[];
/**
 * Checks if the node has the directive
 * @param typeDefinition - definition of type
 * @param directiveName - name of directive
 */
export declare function definitionHasDirective(typeDefinition: SchemaOrFieldDefinitionNode, directiveName: string): boolean;
/**
 * Casts value of directive
 * @param directiveValue - value of directive
 */
export declare const castValue: (directiveValue: IDirectiveValueNode) => string | number | ListValueNode;
/**
 *
 * @param nodeDef - definition of field or node(entity)
 * @param directiveName - name of directive
 * @param defaultValue - default value of directive
 */
export declare function getNodeDirectiveValue<T>(nodeDef: SchemaOrFieldDefinitionNode, directiveName?: string, defaultValue?: T): NodeDirectiveValueType | T;
export declare function getNodeDirectiveNumericValue(nodeDef: SchemaOrFieldDefinitionNode, directiveName?: string, defaultValue?: number): number;
/**
 * Checks if type is builtin type
 * @param typeName - name of type
 */
export declare function isBuiltInType(typeName: string): boolean;
/**
 * Finds definition of given typeName from given definitions
 * @param typeName
 * @param definitions
 */
export declare function findTypeDef(typeName: string, definitions: TypeDefinitionsNode[]): TypeDefinitionsNode | undefined;
export declare function getDirectiveArguments(args?: ReadonlyArray<ArgumentNode>): IDirectiveArgType;
export declare function parseArgValue(argValue: any): any;
export declare const getFieldDirective: (field: IEntitySchemaField, directiveName: string) => IDirectiveArgType;
export declare function fieldHasDirective(node: SchemaOrFieldDefinitionNode, directiveName: string): boolean;
export declare function getArgumentsOfDirective(node: SchemaFieldDefinitionsNode, directiveName: string): Record<string, ValueNode>;
export declare function isArgExistsInDirective(args: any, argName: string): boolean;
export declare function getArgValue(args: any, argName: string): string | string[] | undefined;
export declare function removeDirectivesFromFields(fields: any): any;
export declare function createFieldDefinition(name: string, type: string): {
    kind: string;
    name: {
        kind: string;
        value: string;
    };
    arguments: any[];
    type: {
        kind: string;
        name: {
            kind: string;
            value: string;
        };
    };
    directives: any[];
};
export declare function convertTypeToInputDefinition(definition: TypeDefinitionsNode): CustomInputObjectTypeDef | TypeDefinitionsNode;
export declare function removeDirectivesFromFieldDefinition(fieldDefinition: SchemaFieldDefinitionsNode): SchemaFieldDefinitionsNode;
