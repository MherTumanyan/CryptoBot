"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const isGlob = require("is-glob");
const common_1 = require("@graphql-toolkit/common");
const filter_document_kind_1 = require("./filter-document-kind");
const document_from_string_1 = require("./document-from-string");
const globby = require("globby");
async function loadTypedefsUsingLoaders(loaders, pointerOrPointers, options = {}, filterKinds = [], cwd = process.cwd()) {
    const pointers = common_1.asArray(pointerOrPointers);
    const loadPromises$ = [];
    const found = [];
    const foundGlobs = [];
    for (const pointer of pointers) {
        if (common_1.isDocumentString(pointer)) {
            loadPromises$.push(Promise.resolve().then(async () => {
                const docs = document_from_string_1.documentFromString(pointer, filterKinds);
                found.push(...docs);
            }));
        }
        else if (isGlob(pointer)) {
            foundGlobs.push(pointer);
        }
        else {
            loadPromises$.push(Promise.resolve().then(async () => {
                let content = await loadSingleFile(loaders, pointer, options);
                content = filter_document_kind_1.filterKind(content, filterKinds);
                if (content && content.definitions && content.definitions.length > 0) {
                    found.push({
                        location: pointer,
                        document: content,
                    });
                }
            }));
        }
    }
    if (foundGlobs.length > 0) {
        if (options.ignore) {
            const ignoreList = common_1.asArray(options.ignore)
                .map(g => `!(${g})`)
                .map(p => common_1.fixWindowsPath(p));
            if (ignoreList.length > 0) {
                foundGlobs.push(...ignoreList);
            }
        }
        loadPromises$.push(Promise.resolve().then(async () => {
            const paths = await globby(foundGlobs, { cwd, absolute: true });
            await Promise.all(paths.map(async (path) => {
                if (!path.endsWith('.d.ts') && !path.endsWith('.spec.ts') && !path.endsWith('.spec.js') && !path.endsWith('.test.ts') && !path.endsWith('.test.js')) {
                    let content = await loadSingleFile(loaders, path, options);
                    content = filter_document_kind_1.filterKind(content, filterKinds);
                    if (content && content.definitions && content.definitions.length > 0) {
                        found.push({
                            location: path,
                            document: content,
                        });
                    }
                }
            }));
        }));
    }
    await Promise.all(loadPromises$);
    if (found.length === 0) {
        throw new Error(`Unable to find any GraphQL type definitions for the following pointers: ${pointers.join(', ')}`);
    }
    return found.sort((left, right) => left.location.localeCompare(right.location));
}
exports.loadTypedefsUsingLoaders = loadTypedefsUsingLoaders;
async function loadSingleFile(loaders, pointer, options = {}) {
    try {
        for (const loader of loaders) {
            const canLoad = await loader.canLoad(pointer, options);
            if (canLoad) {
                const found = await loader.load(pointer, options);
                if (found) {
                    return found.document;
                }
            }
        }
    }
    catch (e) {
        common_1.debugLog(`Failed to find any GraphQL type definitions in: ${pointer} - ${e.message}`);
        throw e;
    }
    return null;
}
exports.loadSingleFile = loadSingleFile;
//# sourceMappingURL=load-typedefs.js.map